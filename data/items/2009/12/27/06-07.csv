ID,Type,Story,Parent,Points,Comments,Author,Title,URL,Content,Created
1016827,comment,1015783,1016347,0,0,elblanco,,,"Lots of companies/projects work in the field of information visualization, on the bookshelves of almost all of them, you can find Tufte's books. He's largely considered the leader in the theory of displaying information in as dense and as clear of a method as possible than enables people to perceive the encoded information as rapidly and as correctly as possible.<p>He's best known for sparklines we all enjoy when looking at tables of stock prices, but those are likely the the least of his contributions to the field.<p>references:<p><a href=""http://www.palantirtech.com/"" rel=""nofollow"">http://www.palantirtech.com/</a><p><a href=""http://www.futurepointsystems.com/"" rel=""nofollow"">http://www.futurepointsystems.com/</a><p><a href=""http://www.caida.org/tools/visualization/walrus/"" rel=""nofollow"">http://www.caida.org/tools/visualization/walrus/</a><p><a href=""http://en.wikipedia.org/wiki/Visualization_(computer_graphics)"" rel=""nofollow"">http://en.wikipedia.org/wiki/Visualization_(computer_graphic...</a><p><a href=""http://www.esri.com/"" rel=""nofollow"">http://www.esri.com/</a><p><a href=""http://nvac.pnl.gov/"" rel=""nofollow"">http://nvac.pnl.gov/</a>",1261897145
1016826,comment,1016689,1016689,0,0,asciilifeform,,,"This is why:<p><a href=""http://www.loper-os.org/?p=85"" rel=""nofollow"">http://www.loper-os.org/?p=85</a><p>Racing computer languages the way one might race horses is a fundamentally misguided thing to do. The race is to the Blubulous simply by virtue of being a race.",1261896862
1016825,comment,1016262,1016422,0,0,chromatic,,,"> Liquid explosives are extremely unstable.<p>They're stable enough when TSA makes passengers throw them all in a trash can before passing through screening.",1261896749
1016824,comment,1016494,1016494,0,0,cmars232,,,"This is real, not a joke, right?",1261896743
1016823,comment,1016583,1016621,0,0,pg,,,"Curiously, it's inherently impossible to compare what I think matters most for languages: solving new problems.  To compare two languages you have to have people solve the same problem, and that means it has to be a predefined one.",1261896732
1016822,comment,1016396,1016396,0,0,ThinkWriteMute,,,"Related to the article but: Why is Blogger the red-headed step child of Google? I stopped using it recently because over the last 3 years it's barely changed. Posting a comment requires 3 page refreshes, 1 auto-scroll, and breaks the look of the website.<p>There are so many simple things Google could do to improve Blogger. Obvious things too.",1261896715
1016821,comment,1016583,1016812,0,0,silentbicycle,,,"Yeah. He caught monotone at a bad time. Graydon had just gone on sabbatical...<p>Also, 'disaster' is a bit...harsh. As I heard, he just telnet'd and asked for ""help"".",1261896696
1016820,comment,1016689,1016806,0,0,tel,,,"Within some problem spaces might it not be true the some languages are somewhat definitively better than others on average?<p>Knowing many languages definitely operates as a toolbelt for different problems, but there's a reason languages die out. Could that same reason not still apply, at least slightly, in the languages still alive?",1261896695
1016819,comment,1016262,1016588,0,0,thwarted,,,"Considering how this thread expanded, I'm not sure who you're responding to.<p>It was more of a ""this is what my tax dollars is paying for?"" eye rolling moment.  That being said, the TSO who joked that we couldn't bring our baby on the plane was apparently loitering not doing whateve her job was and was assigned to go do something by her manager as we finished putting our shoes on, so there are at least some professional in management at the TSA.",1261896657
1016818,comment,1016016,1016016,0,0,elblanco,,,"It's usually not the distance to the plug I have a problem with, it's the number of outlets I need more of.",1261896594
1016817,comment,1015684,1016288,0,0,pgreenspun,,,"My article did not assert that a pilot became captain at a foreign carrier after 270 hours. The article asserted that a person became captain at a foreign carrier after thousands of hours... nearly all as second in command. That is a very different background than someone who becomes captain at a major U.S. airline (who would have to have been pilot in command at a regional airline for 1000+ hours or pilot in command of a USAF airplane).",1261896570
1016816,comment,1016260,1016479,0,0,csallen,,,"I'm not sure the author is saying he has what it takes to be an amazing entrepreneur. He seems to be referencing his education and skillset to prove a much different point -- that even if he starts a business and fails, he won't have much to fear because getting a job will be easier for him. That's a valid point.",1261896504
1016815,comment,1016739,1016739,0,0,elbenshira,,,"I've never understood singularitarians. Why make such a big fuss over super humans and real AI and whatnot? There is too much talk backed with no results. Let the real scientists continue doing what they do, and perhaps some of the ideas will bear fruit.<p>But the funny thing is that at the end of it all, being a ""super human"" won't make your life any better. Technology can't save humanity.",1261896401
1016814,comment,1015999,1016571,0,0,gruseom,,,"Yes, ""Rinda"" is ""Linda"" pronounced with a Japanese accent, which along with the fact that Ruby starts with an R makes it the perfect name for that particular project. Unfortunately these things stop being funny and start sounding kind of mean when you spell them out in writing. My comment is absolutely not in that spirit; I just think it's the quintessentially whimsical name, really the only possible name for a Ruby implementation of Linda, and I cling to the fantasy of a room full of people (or at least one) rolling on the floor laughing when they thought of it.",1261896401
1016813,comment,1016583,1016621,0,0,asciilifeform,,,"> Surely if lisp makes a programmer N times more efficient then it would be easy to study scientifically. Have there been any studies comparing productivity?<p>I began to write a reply to your question, but decided that it deserved its own post:<p><a href=""http://www.loper-os.org/?p=85"" rel=""nofollow"">http://www.loper-os.org/?p=85</a>",1261896346
1016812,comment,1016583,1016798,0,0,krakensden,,,"Both statements are true- it was a hack to replace BitKeeper after the Tridgell disaster, and it was inspired by monotone, which he deemed irreparably slow.",1261896338
1016811,comment,1016396,1016771,0,0,ThinkWriteMute,,,"Here's what you would have said if you wanted to be correct:<p><i>20th Century mark up languages are absolutely retarded for designing web pages and breed bad layout design.</i><p>Yeah, I know I'm going to get down-voted because people lurv HTML, but having had to whip it into shape lately this was totally worth it.",1261896332
1016810,comment,1016583,1016728,0,0,krakensden,,,"Why do you think it's a tremendous improvement over BitKeeper? Have you used it?",1261896210
1016809,comment,1016260,1016479,0,0,briancooley,,,"Indeed, it seems to me that he would fail miserably at starting a company because he equates the product/service his company would make/offer with his education.<p>It's as if Google would have been successful just by branding their search as ""Google - the search engine developed by Stanford PhD's""<p>What's rare and valuable are people that accomplish a lot with a little. I have no idea if the culture at MIT preferentially fosters that kind of dogged resourcefulness, but thinking you're done before you even get started because of a handful of letters on a piece of paper is a start in the wrong direction.",1261896118
1016808,comment,1016583,1016644,0,0,silentbicycle,,,"Oddly, it can also be a downside. A language that makes reinventing the wheel <i>too</i> easy means that people can spend more time saying, ""Psh, I could do that in a couple hours""  than sharing. Then, when people want to know what the library is to use for parsing HTTP headers (or whatever), everybody and their nephew shows up to suggest their own half-assed framework. It doesn't inspire confidence.<p>Take that to its logical extent, and ... <i>wait, which Lisp implementation do you use again? Mine only works with SBCL, crap, nevermind.</i><p>When somebody has a really thoroughly debugged C library, it can be like huddling everyone together by a fire for warmth in the tundra. If you don't share, man, that's just <i>cruel</i>.",1261895864
1016807,comment,1015311,1016157,0,0,rick_2047,,,"Realized my mistake here, sorry for the misinformation.",1261895661
1016806,comment,1016689,1016782,0,0,silentbicycle,,,"People seem to assume that there's a <i>linear</i> continuum with a ""best"" language, rather than thinking that certain languages' designs make them better suited to handling certain kinds of problems.<p>For example, sometimes lazy evaluation greatly simplifies problems, and sometimes it makes them vastly more difficult to reason about. The language is just a tool to help clarify and solve your problem, and a language that doesn't fit can make it worse.",1261895513
1016805,story,,,5,1,jgalvez,"Adventures in Cocotron (cross-platform Cocoa apps)",http://macdaddyworld.com/2008/10/27/adventures-in-cocotron/,,1261895494
1016803,comment,1014450,1014450,0,0,comster,,,"I think MS posted this.",1261895203
1016802,comment,1016515,1016515,0,0,bearwithclaws,,,"<a href=""http://lawandorderinrussia.org/"" rel=""nofollow"">http://lawandorderinrussia.org/</a>",1261895177
1016801,comment,1016689,1016689,0,0,scythe,,,"<a href=""http://stackoverflow.com/questions/1894453/development-time-in-various-languages/"" rel=""nofollow"">http://stackoverflow.com/questions/1894453/development-time-...</a> should be helpful.<p>SPOILER: Ada and Haskell get high marks.",1261895077
1016800,comment,1016689,1016754,0,0,silentbicycle,,,"Historically, it's been dominated by OCaml, Haskell, and C++ (!) people.<p>Is it just me, or <i>has Lisp not placed once in the eleven years of the contest</i>?<p>In a frigging <i>academic contest for functional programmers?</i><p>Where they were beat by <i>assembly</i> and <i>TeX</i>???<p>Ouch!<p>(In all fairness, they still have _Lisp in Small Pieces_, _Paradigms of Artificial Intelligence Programming_, and _SICP_. Even if nobody uses the language for real programs, it's still in the running.)",1261895033
1016799,story,,,4,0,Ben_Dean,"Websockets Specification",http://dev.w3.org/html5/websockets/,,1261894966
1016798,comment,1016583,1016650,0,0,silentbicycle,,,"Nah, I think it's the git that Torvalds wrote when he decided that Monotone had some pretty cool ideas (the whole distributed VCS thing) but was slow and written in icky C++.",1261894932
1016797,comment,1016689,1016781,0,0,tel,,,"Running through these papers, the Prechelt (Tcl/Python/Perl/Rexx) paper probably comes closest to producing the kind of analysis desired, but at the end of the day they're all begging for more controls.<p>In particular to some of the Prechelt paper's most interesting results (LOC, comments, time spent) are marred by the collection methods (""script"" languages were not sampled under controlled settings).",1261894641
1016796,comment,1016583,1016725,0,0,tolenka,,,"<i>My point is that both are way ahead of your typical Java shop, and way ahead of Windows, and that FOSS and Linux do not deserve the beating given to them by the author of the blog post.</i><p>I think that's a bit unfair to Java shops. =)<p><i>AFAIK CFS is considered >= ULE2 by most people, and I'm not aware of significant regressions introduced by CFS, so the high degree of conservatism you pointed out in the FreeBSD project wouldn't have been warranted in this case. I don't have the background to argue the finer points of this issue, but it's off topic for this thread, anyway.</i><p>CFS is based on knowledge gleaned from <i>years</i> of work on earlier schedulers by Con Kolivas and Ingo Molnar. In the meantime, the scheduler was replaced several times in the ""stable"" tree while they ""figured it out"". It took just as long, made a bigger mess, and ultimately cost more to produce (not to mention all the flamewars and bad blood engendered in the process).<p>Whether CFS >= ULE2 is a very nuanced question, but it's fair to say that the schedulers are much closer.",1261894586
1016795,comment,1016583,1016749,0,0,randallsquared,,,"I don't think Lisp has that problem.  Rather, it has the ""problem"" that it's easier to build the 20% you need of that library than to find the library, understand enough to do the bit you need in the face of that inevitable impedance mismatch between your abstractions and the library author's, figure out how including it impacts the rest of your system including the dependencies...<p>In other languages, this is just something everyone has to live with, and because of that, libraries face strong selection pressure to be one or more of simple, fast, standard, etc.  There is no particular pressure like that in Lisp, since there's a much smaller domain where it's easy to understand why you need a thing, and troublesome to build it.  To a much greater degree than mainstream languages, then, there are almost as many ""language + standard library"" sets as there are Lisp developers.  You can see this same effect at work in Python web frameworks, I think.",1261894538
1016794,comment,1016763,1016763,0,0,mbrubeck,,,"This isn't a coherent strategy, just a collection of things that worked for me.  Feel free to pick and choose:<p>- Isolate yourself.  Bring a book on the bus (or to the park/airport/restaurant) and don't bring any other distractions.  The internet is your enemy; if you want to digest large works, set aside some time where you won't spoil your appetite by grazing on RSS feeds and blog posts.<p>- Be willing to skim, skip sections, or quit early.  The book will still be there later, and you can always read it again if it turns out you missed something worthwhile.<p>- Write reviews or summaries in a diary, blog, or paper notebook.  Include quotes you found interesting.  Copy the quotes by hand, it will help you remember them later.<p>- Have two or three books ""in progress"" at any given time.  (I like to read one fiction and one nonfiction book at a time.)  Let yourself choose the book you're in the mood for right now.  Be willing to put a book away and switch to a different one if you're not in the mood, or not getting anything out of it right now.  Maybe you'll be in the mood later, or maybe it's not the right book.<p>- Do the homework.  If the book teaches knowledge you can apply to problems (like a programming language or a field of mathematics) and doesn't have exercises, make up your own.  Apply it to something you're working on, just for practice, even if it's not the best tool.<p>- For a book that's <i>not</i> teaching a practical skill (e.g. fiction, history, biography), actively compare it to current events, or to your own life or work, or to other people/books/fields.  If you can't find some relevance to something outside the book, why are you reading it at all?  (There are valid answers, but you should at least ask the question.)<p>- Chase references.  The library is a web, and footnotes are hyperlinks.  Follow the links back in time to find out what the author was reading and thinking at the time.  In scholarly work, find the classic papers/books that everyone cites, and actually <i>read</i> them (most people don't).   This can give you some of the endorphin-fueled ""seeking"" behavior that makes web surfing addictive.  Rate every book you read on a site like Amazon, and then use its recommendations to help refill your queue.<p>- Find better books.  There are so many worthwhile books that you will never read them all in your lifetime.  You don't have time to waste on bad books.  If a book is poorly-written, toss it unless it contains some knowledge or insight that you consider really important.  (Similarly, a book can be very well-written but have content that adds nothing to your life; skip that one too.)  Figure out which books you got the most out of, and seek out similar ones.  Find sources of good recommendations.  Again, be willing to put down a book if you're not getting anything out of it.<p>- Read with partners.  Join or form a book group, or convince a friend or two to read along with you.  (You don't need formal discussions; it can just give you another convenient conversation topic next time you hang out.)   Recruit co-workers, or look online (GoodReads, or forums like this one).  This works especially well with intimidating but well-regarded books (SICP, Ulysses, Wealth of Nations), since you can find other people who want to read them too.  <a href=""http://infinitesummer.org/"" rel=""nofollow"">http://infinitesummer.org/</a> helped spur me to read Infinite Jest, and I'm planning to read 2666 with them next month.",1261894486
1016793,comment,1016494,1016494,0,0,pmorici,,,"I'm curious how much that thing weighs.  If it adds a lot of heft to the bike that is going to make it require more human effort to drive it to begin with.",1261894421
1016792,comment,1016262,1016422,0,0,Daniel_Newby,,,"""Current detection technologies can't really detect explosive substances ...""<p>There are plenty of direct explosives detectors, such as the ICx products: <a href=""http://www.icxt.com/products/icx-detection/explosives/"" rel=""nofollow"">http://www.icxt.com/products/icx-detection/explosives/</a>",1261894374
1016791,comment,1016441,1016703,0,0,GrandMasterBirt,,,"lol!<p>Hey in yovile you gota send messages to friends for cash. So... What everyone winds up doing is sending ""asd"" messages to everyone on their friend list every day.<p>Sure, thats not spam, its ""asd"".",1261894219
1016790,comment,1016441,1016441,0,0,norova,,,"Tasteless and a tiny bit offensive, but definitely not worthy of a C&D, in my opinion.",1261893977
1016789,comment,1016677,1016677,0,0,silentbicycle,,,"I suspect part of your dilemma comes from too many CS students having <i>the same problems</i>. There are already a zillion webcomic downloaders, blogging engines, etc. You have other interests, yes? Perhaps you're geeked about baseball card statistics, blackjack, typography? Scratch an itch. Run with it.<p>What tools would help solve (or even explore) your problems? Make them.<p>That's one side of ""real programming experience"". Another side (which you won't learn from small - but ever so useful - projects) is how to work with other people on a common codebase under pressure, both writing clean code and interpreting other peoples' frantic twilight hacks. Kernighan and Pike's _The Practice of Programming_ is as good a style guide as any, and just practice reading code from open source codebases. Good code (Lua and the BSD userland utilites are good for bite-sized pondering) and bad code will teach you different things.",1261893933
1016788,comment,1016689,1016732,0,0,tel,,,"That would undoubtedly be qualitative, though you're right that it's probably the closest thing to programmer productivity you can measure.<p>I think you're wrong that reductionism can't find an interesting gem buried below. Productivity is something difficult to measure because it takes a long time and has a lot of influencing factors, but if you can split it apart just a little bit and lose some of the confounders you might be able to give at least a little quantitative foundation to claims shown anecdotally.",1261893857
1016787,comment,1016282,1016394,0,0,dgordon,,,"Of course, I meant ""There is nothing so permanent...""",1261893840
1016786,comment,1016677,1016677,0,0,chipsy,,,"Take a big idea and bite off the smallest piece of it. Preferably a boring(or boring to most people!) problem with one or more obvious solutions. Why boring? Because programmers have a nasty habit of wanting to jump to interesting, challenging problems at an early stage, before they have properly evaluated real requirements of the particular domain. Hence there are lots of dead projects with a fancy internal design and nothing working or useful about them. But, on the other hand, many programs can eventually reach a stage where the programming problems become simultaneously interesting and useful; it's just that you can't do this instantly because you don't know the real requirements yet.<p>Instead, you can build prototypes to find those requirements. When you're solving ""real world"" tasks, a proof-of-concept solution can often be done as a weekend to two-week project. It'll look trivial and do trivial things. It's the progression and accumulation of little features and fixes that move the program from the proof-of-concept or prototype stage into a real, useful app. Eventually the accumulations overwhelm your original design, and at that point you'll have the information necessary to do things ""the right way"" - how much performance is necessary, what features are relevant, if the language and platform are appropriate matches, etc.",1261893802
1016785,comment,1016583,1016668,0,0,gridspy,,,"Perhaps high-school or college students are poor evaluators of a language. I am not only interested in how productive you are after 1 year of using a language, I'm also interested how productive you are after 10 years using that language, or with 10 years of legacy code.",1261893771
1016784,comment,1016584,1016584,0,0,bobbyi,,,"Being sane is overrated.",1261893714
1016783,comment,1016583,1016706,0,0,tolenka,,,"<i>I think what the commenter meant was the cathedral vs the bazaar model of development. Would'nt FreeBSD, NetBSD, etc all be in the same boat as Linux? Granted that Linux has a benevolent-dictator-aka-linus, but that does not make it deviate too much from the bazaar model.</i><p>Most other kernel development teams operate with a considerably more conservative approach (""the cathedral"") than is engendered by Linux and specifically enabled by dvcs/git (""the bazaar"").<p>In Eric Raymond's essay, he contrasted the two development models as such (quoting wikipedia):<p>The Cathedral model, in which source code is available\n with each software release, but code developed between\n releases is restricted to an exclusive group of software\n developers. GNU Emacs and GCC are presented as examples.<p>The Bazaar model, in which the code is developed over\n the Internet in view of the public. Raymond credits\n Linus Torvalds, leader of the Linux kernel project, as\n the inventor of this process. Raymond also provides \n anecdotal accounts of his own implementation of \n this model for the Fetchmail project.<p><a href=""http://en.wikipedia.org/wiki/The_Cathedral_and_the_Bazaar"" rel=""nofollow"">http://en.wikipedia.org/wiki/The_Cathedral_and_the_Bazaar</a><p>I'd say just about every other kernel available today is developed in ""the cathedral"", although even then I think that Raymond's comparison (and judgments) are a <i></i>vast<i></i> oversimplification.<p><i>For all its flaws, git (and github) are becoming the preferred choice of hackers everywhere</i><p>Some very vocal people, but not what I'd say ""hackers everywhere"". As a regularly user of hg and git, I'm not particularly convinced that dvcs provides significantly compelling advantages outside of Linux's development model.<p><i>If any, Solaris is the only counter-example to Linux - not FreeBSD.</i><p>I'm not sure why you'd say that is.",1261893702
1016782,comment,1016689,1016723,0,0,tel,,,"That's how I interpret it as well, but in order for Blub to be an interesting thing experiment it makes the assumption that languages form some sort of continuum of power/ease/abstraction/usefulness. Generally, the only one of those four people can agree upon (sometimes) is abstraction and that's not even necessarily the most important of the four.<p>I personally think one of the most interesting dimensions to analyze a language would be in how quickly one could prototype a problem. Lisp often is said to score well here; the Cs are thought to fall short; Arc was more or less designed to optimize this technique in online apps; and Haskell somehow manages to perform here despite a lot of criticisms in its design. So there's a hypothetical contiuum. Prove to me it exists and then you can pick your Blub.",1261893626
