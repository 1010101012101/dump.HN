ID,Type,Story,Parent,Points,Comments,Author,Title,URL,Content,Created
207800,comment,207732,207732,0,0,gaius,,,"True in a world where you have a 1:1 application to database mapping.<p>However out here in the <i>real</i> world, it's common to have n:1, i.e. many applications all accessing and modifying a single database. The question is, then, how do you implement common or mandatory logic in a way that avoids having to re-implement it in every application, and protects the data from a misbehaving application? Why, you expose access to the underlying data through stored procedures, problem solved.",1212490582
207799,story,,,2,0,naish,"The Filter Has Launched",http://www.readwriteweb.com/archives/the_filter_has_launched.php,,1212490237
207798,comment,207253,207253,0,0,gaius,,,"I am as scared of Perl 6 as I am of the Loch Ness Monster, Bigfoot, and other things that donÂ´t exist...",1212490121
207797,comment,207253,207496,0,0,shiro,,,"Yes, with nicer closure syntax and/or lazy evaluation, lots of macro use cases can be eliminated.  However, making single definition work as multiple definitions is a pattern that I haven't find ways other than macros.<p>For example, think of defenum macro that expands to a bunch of defconstants:<p><pre><code>    (defenum (ONE 1) TWO THREE FOUR (TEN 10))
     =>
    (progn (defconstant ONE 1)
           (defconstant TWO 2)
           (defconstant THREE 3)
           (defconstant FOUR 4)
           (defconstant TEN 10))
</code></pre>
(Haskell programmers would use types for enum-kind of stuff, but suppose that you really need to associate numbers to those symbols.)<p>Or you can go further to name the enum itself, defining conversion functions between symbolic names and their values:<p><pre><code>    (defenum the-numbers ONE TWO THREE ...)
    =>
    (progn
      (defun symbol->the-numbers (sym)
        (case sym
          ((ONE) 1) ...)))
      (defun the-numbers->symbol (num)
        (case sym
          ((1) 'ONE) ...)))
      (defconstant ONE 1) ...)
</code></pre>
Without macros, you need to have some procedural interface to modify the global environment to realize these (which is, imho, worse than macros).",1212489880
207796,comment,207590,207590,0,0,davo11,,,"Are your cookies very good? Do people come around to your house to eat your cookies no matter how rude you are to them? If so go for it, if not well I'd be thinking about something else, the snack food market is incredibly competitive and done to death.<p>Even worse, say you do get it working whats to stop someone else opening a cookie shop next door? As others have said business schools are made for this sort of ahem 'cookie cutter' business model.<p>Run the numbers and if you think it will work well go in with both eyes open and good luck.<p>If there's three of you why not two get a job and the third run the shop full time, get some cheap student labor for busy times and as it takes off the other two can wind up their other jobs, or if your IT guys get short term contracts and rotate even if its wildly successful it will be a year or two before it could support 3 people full time.",1212489103
207795,comment,207486,207646,0,0,DougBTX,,,"Assuming you know the core Ruby library, would you call this explicit or implicit?<p><pre><code>    class GetterDone
      attr_reader :a, :b, :c, :d
    end
</code></pre>
Rather than being a runtime attr.startswith check, this will generate actual ""return self.foo"" methods in the class.<p>Think of this as generating code using a UI, except you record the minimal UI commands, rather than putting the full output into your source files. The commands themselves are still explicit, it's just that they contain only the interesting information with the minimum amount of boilerplate.",1212488589
207794,comment,207247,207728,0,0,haasted,,,"There doesn't seem to be anything about it in HN's robot.txt.<p>Of course, it may have been implemented in other ways.",1212488580
207793,comment,206893,207710,0,0,iamelgringo,,,"He's making a killing with his ""ugly"" products and had 17x revenue growth in 5 years.  I'm sure if he could charge an extra $100 per license, he'd make the software prettier.  As it is, he primarily sells bug tracking software to Windows programmers.  It's not exactly a sexy, design driven business.",1212488528
207792,comment,203040,203069,0,0,gumbah,,,"walterk does have a point... but it's pretty ok... i bought a ""crumpler"" keyboard protector with it, which can also be used to wipe the screen and ""grease"" of the surface",1212488317
207791,comment,207125,207600,0,0,mchristoff,,,"pandora pays royalties to soundexchange, the same way internet radio does. they in theory pay artists. although, i'd be interested in hearing how many artists actually get paid by sx and how much.",1212488251
207790,comment,207486,207486,0,0,DanielBMarkham,,,"OO is all goodness, just like FP. But the way it is implemented by some people can make it impossible to easily understand or modify -- just like FP.<p>OO is simply organizing your code before/as you write it. Combined with UML, it can be a kick-ass way of describing your general strategy for dealing with complex problems. Or it can take something simple and make it into a monster -- it's up to you.<p>Another way of looking at OO is that you are building your own language as you go along by starting with nouns (types) and adding all sorts of verb-clauses to hook them together. You can do this in a super-cool, easy-to-understand way, or you can get a bit carried away and try to recreate the dictionary when you only need a few nouns and a few verbs.<p>OO's goal is not tight, beautiful, concurrent code. You want to feel like Picasso or Spock, go write FP.<p>For all of those reasons, OO just isn't as sexy as FP. You're not writing something that scales to a zillion users right out of the bag. You're not doing a lot of meta-programming, recursion, lambda calculus and such. You're not writing anything sneaky, clever, or bound to impress the other nerds. Everything just looks plain Jane. Add to that all of the examples of bad pattern usage and other atrocities in the OO world and I can easily see why other ways of doing things can seem more attractive.",1212488215
207789,comment,207125,207765,0,0,mchristoff,,,"yup. they pay ascap, bmi, and/or sesac performance royalties.",1212488025
207788,story,,,2,1,hyperlexic,"It is a Sad and Beautiful World",http://www.hyperlexic.com/it-is-a-sad-and-beautiful-world/,"I am spending my life writing user manuals for  products that don't exist. They might exist someday. But is this my fate?",1212487956
207787,comment,206697,206697,0,0,TomW,,,"check out sites such as<p><a href=""http://www.notely.net/"" rel=""nofollow"">http://www.notely.net/</a> - lets you share notes with friends that are signed up, also provides org tools for students
<a href=""http://stu.dicio.us/"" rel=""nofollow"">http://stu.dicio.us/</a> - i believe does the same thing but is down atm
<a href=""http://wwwnotesake.com/"" rel=""nofollow"">http://wwwnotesake.com/</a> - again same thing<p>there are others too",1212487736
207786,comment,207486,207743,0,0,cturner,,,"""Inheritance is not important, but the organisation of data""<p>Good point. I missed this when I first left Java, because in Java you get these nice classes. Over time I've found I use class structures a lot less, or in some situations I'll hack them. The other day I was writing a tree builder where in java I would have had a different class for ""node"", ""attribute"", etc, all extending from element. In my python impl I just had a class ""element"" with a string field ""e_type"" which was ""attribute"", ""node"", etc and then I stuck other stuff into a dictionary in that object as I needed it. Over time I've found that the extreme brevity improvements combined with blocks of documentation to describe the purpose of a grouping of code more than make up for the loss of code-based structure.<p>Again on the topic of organisation of data - in databases you get a lot of automatic documentation because the schema abstraction we're used to is so widespread and accepted. This is one of the reasons I love to stick with relational databases even though I know that there are good arguments, particularly in FP communities, advocating more practical forms of datastore.",1212487434
207785,comment,207408,207408,0,0,jauco,,,"there's an even better technique called Chisenbop. It allows you to defer basic calculations to a mechanical process. It's described in ""mind performance hacks"" from o'reilly.<p><a href=""http://www.ludism.org/mentat/MindPerformanceHacks_2fTurnYourHandsIntoAnAbacus"" rel=""nofollow"">http://www.ludism.org/mentat/MindPerformanceHacks_2fTurnYour...</a>",1212487364
