ID,Type,Story,Parent,Points,Comments,Author,Title,URL,Content,Created
23314,comment,23300,23304,0,0,JamesT43,,,"Thats actually going to be at www.hacketyhack.net.",1179621665
23313,comment,23312,23312,0,0,jamiequint,,,"Are any news.YCers here at RailsConf? I met one yesterday and was hoping to catch up with others if they are here.",1179620701
23312,story,,,2,1,jamiequint,"News.YCers at RailsConf?",,,1179620657
23311,story,,,1,0,jamiequint,"VentureBlog: The Widget Economy",http://p6.hostingprod.com/@www.ventureblog.com/articles/indiv/2007/001278.html,,1179620565
23310,comment,23300,23307,0,0,rms,,,"Sorry, I meant languages that actually allow for functional programming, not languages that are exclusively that way.",1179619505
23309,comment,23300,23300,0,0,dazzawazza,,,"+1 for python.
Why? excellent docs, excellent libraries, excellent books, flexible language thats easy to learn.",1179619428
23308,comment,23300,23300,0,0,jaggederest,,,"lisp, haskell, prolog, forth, erlang, smalltalk, python, ruby, c, java<p>I think lisp will be adequately enunciated, so I'll move on to the others<p>Haskell is a lazy, strongly-typed functional language. It's syntax is very close to mathematical notation, and it enables code reuse by not allowing side effects. It'll teach you to think in actual algorithms, where most languages teach you to think about how to implement those algorithms.<p>Prolog is a logic language. It'll teach you logic, and some of the fundamental ideas from that field. Backtracking search, unification, and other interesting ideas.<p>Forth is a reverse-polish-notation stack language that is very 'close to the metal' and yet a higher order language than C. Forth will teach you more about the workings of a computer than anything but assembler, and it won't break your soul like assembler might.<p>Erlang is strict strongly-typed functional language that is all about concurrency. Right now it's probably the best language to write highly concurrent applications in, and, as it turns out, most of the internet can be made highly concurrent.<p>Smalltalk is the mother of all object oriented languages, and shares with lisp the interesting concept of a running image. In smalltalk, everything you do is in a live instance of an image, and to deploy, you simply move the instance over and run it on the server. This also one of the first languages to have an effective refactoring browser.<p>Python is a dynamic object-oriented language that incorporates features from a lot of previous languages. It's got some interesting things and a fairly nice syntax. Take a look at TurboGears, Pylon, and Django<p>Ruby is a dynamic object-oriented language (lisp + perl) that is (like lisp) all about metaprogramming. Ruby has also got an interesting framework that is becoming notorious, Rails, which makes OR mapping and quite a few other things brain-dead easy. If you get into the internals of rails, you'll learn a lot about metaprogramming.<p>C is The Language. If it has to be fast, small, and close to the metal, C is the go to language (no pun intended) There are a lot of situations where you'll end up needing to rewrite in C if you hit performance problems, so knowing some C will let you squeeze about an order of magnitude of performance out of things. Plus, you can start to understand drivers for your hardware here.<p>Java is less about the language and more about the IDEs. With the possible exception of Smalltalk, Java has the best IDEs and refactoring software. This is the kind of thing that most languages should have, but don't.<p>Anyway, this is kind of just a menu, but if you learn three or four of these, you'll be well on your way to deciding which one suits your style.",1179619328
