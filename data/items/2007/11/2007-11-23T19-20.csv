ID,Type,Story,Parent,Points,Comments,Author,Title,URL,Content,Created
83029,comment,82864,83013,0,0,edw519,,,"lol - I've often wondered about that.  I once remarked to a partner, ""Why do we see so much crap?"" He responded, ""Cause the people who know what they're doing have no reason to call us.""",1195847805
83028,story,,,2,1,comforteagle,"hardware/bandwidth % of revenue",,"What percentage of revenue are your startup's servers/bandwidth cost?<p>What is a good percentage range to aim if any if you're in the black?",1195847252
83027,comment,82864,83025,0,0,DanielBMarkham,,,"I'm trying to find some point of agreement with you.<p>
I think from your comment, we can agree that there are two scenarios to consider: when the programmer is in control of the product and when the schedule is in control of the product. ""Programming is not always so time-and-performance-sensitive, but it's not time-insensitive either.""<p>
Here's the deal: when you stop your design process and kick the compiler up and start coding, you haven't stopped your design work at all, you've simply switched from top-down to bottom-up design. Every line of code you write is a validation/denial of the assumptions and planning you're supposed to do before you start. If you're not refactoring aggressively as you go along, you're not taking the chance to see where your code is supposed to be going: you're simply trying as hard as you can to get to point B from point A. It's like driving a car from one side of the field to the other by letting go of the steering wheel and hoping it gets there okay. Most of the time you make it to the other side just fine, but you have zero control over where on the other side you're going to end up.<p>
To me, that's hacking, and I mean in a bad way. I've been known to hack like a freaking electric weed-eater, trust me! But that's when something else is out of whack on the project. It's a sign that there are serious problems. When you're doing it right, your code is constantly evolving as you refactor to the point where changes become less and less of an issue. So good programming means you spend all the time necessary to refactor with the knowledge that you'll going to make it back in spades later on.<p>
It's like when playing rummy, and you decide to pick up a huge stack of cards. At first, it seems like a crazy move, but if you know how to play the game, you realize that the only way to win is to constantly redefine the problem domain of what you have in your hand. Hacking doesn't get you that -- it just gets you to point B no matter what. It may not be the sign of poor programmer, but it's definitely a red light that something is out of whack somewhere.<p>
My opinion only. Your mileage may vary. Do not attempt to drive heavy machinery after reading my comments. Consult a physician before beginning a regimen of refactoring. Etc.",1195847155
83026,comment,82949,83016,0,0,hello_moto,,,"The employer treated me alright, good benefits, nice working environments. I value trust and connection.",1195846534
83025,comment,82864,82984,0,0,Goladus,,,"It is obsessing if it detracts from the end product.  I'm not saying DRY isn't good practice or that chunks of code duplication are just fine and dandy.  However, bits of code duplication are hardly a viable litmus test for judging quality of a programmer.  When an actor screws up a line in a performance, he can't afford to stop and correct it.  In fact, if he stops to correct a meaningless line he'll cause far more damage than if he'd just kept going.  Programming is not always so time-and-performance-sensitive, but it's not time-insensitive either.<p>Perfect programmers may manage to avoid duplicating code on the first try.  But unless we have dozens of Mozarts posting here I'd guess that no one qualifies.  That means we make mistakes, and the question of whether correcting those mistakes is good practice or obsession depends on the circumstances.
",1195846174
83024,comment,82835,82835,0,0,allenbrunson,,,"there have been so many times when microsoft could have easily wound up like lotus and ibm, i.e., unable to embrace change and suddenly irrelevant.  but bill was always there to see the problem and point the company in the right direction.  classic example: the rise of the internet in 1994.  what happens when the next big inflection point comes and bill isn't there to turn the ship?  personally i don't think ballmer can possibly fill that role.",1195845348
83022,comment,82743,82743,0,0,cellis,,,"happy late thanksgiving",1195844694
