ID,Type,Story,Parent,Points,Comments,Author,Title,URL,Content,Created
1138594,comment,1138280,1138456,0,0,Groxx,,,"Making the top-tier artificially better is annoying.  I seriously dislike it, and I do extremely well in most shooters.  It hides skill, because one quite-good player with a lucky start can dominate an entire game.  Even if that doesn't happen, it still screws over the people learning / less skilled, which just prevents people from getting better, which prevents more people from playing.<p>My personal favorites are top-deprecating, where the top player is slightly easier to hit / harder to play / worth more points, or totally flat.  It makes it extremely hard to <i>really</i> shine in a game, and when someone maintains a good score, they've earned it.",1266638354
1138593,comment,1137818,1137818,0,0,BrentRitterbeck,,,"For me, BoA back to school.  Technically BoA didn't fail, but I viewed the recession as time to go back and get graduate credentials.  I am currently working on a MSFE.",1266638328
1138592,comment,1138536,1138588,0,0,Harj,,,"not yet, we'll be doing a few meetups in different cities over the next few weeks.",1266638288
1138591,comment,1138187,1138534,0,0,tptacek,,,"No law requires a company with 200 employees to have in-house counsel.<p>Companies with 200+ employees will tend to be negotiating several contracts per week. In-house counsel saves them money.<p>When you're negotiating with a smaller company that's round-tripping with an outside firm for every redline to every contract, there's always a chance that one side or the other will say ""fuck it"" and sign, because legal drama is getting out of hand.<p>When you're negotiating with a firm with in-house counsel, there is virtually no chance that anyone without a board seat can say ""fuck it"" to legal.",1266638119
1138590,comment,1138481,1138559,0,0,jerf,,,"I don't know about that. When you get to the ""second-level"" stuff, it can be weird.<p>Lately, partially as an exercise and partially to get a project of mine going the way I'd like to see it going, I've been working with the State monad directly. Using the state monad is trivial. Understanding how the state monad does its thing is slightly less trivial, but just a matter of following along the definitions and doing the appropriate substitutions. Understanding where the state monad came from and how to modify it to do what I want... now <i>that's</i> starting to get tricky.<p>I blundered around for a bit trying to reconstruct the state monad without actually looking at it and came to the conclusion it wasn't possible. Except that it clearly <i>is</i> possible because it's part of the standard library. The problem was that it had never really occurred to me to put a function in the type signature itself, the way the state monad does, and despite how simple it looks it has really hit home that I don't really <i>grok</i> the thing yet. I do not mean to overmystify; like I said I <i>follow</i> the thing perfectly well, a minimal and perfectly functional definition of the thing is like 10 rather simple lines and there's an upper limit to how confusing 10 lines can get, but... if you can't modify something you certainly don't <i>grok</i> it.<p>Yesterday night I realized I have felt this way before, but it had been such a long time that I hadn't instantly recalled it. I felt this way when I learned about pointers. My first language was Commodore 64 BASIC and I suffered the Dijkstra brain damage, but I got better. I never had the freakout that some people have with pointers, I got the base mechanics right away, no problem. But it took me a while to <i>grok</i> them, and in particular what they are good for. To come to the level of understanding that I might plausibly convince myself that I could come up with the Tortoise and the Hare linked list cycle detection algorithm on my own, or to come to the point where I could comfortably deal with pointers to pointers to functions that take pointers to functions that take an int and return another int without flipping out.<p>Or another example, I fell right into this: <a href=""http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/"" rel=""nofollow"">http://lukepalmer.wordpress.com/2010/01/24/haskell-antipatte...</a> . Same reason, BTW; I wanted to write a ""concrete datatype"" when what I really needed was functions right there in my datatype. It really strikes me as the same sort of problem you can run into in C or C++ if you try too hard to avoid pointers; you end up with crazy ass designs that end up copying too much stuff around, and are ever stuck with being able to not really quite use the language to its fullest.<p>I'm feeling the way I did when I learned about pointers, and I recognize that I've got a ways to go before I'm comfortable with this sort of thing. (And I get the same results now when I diddle around with the state monad that I remember getting when I tried to modify pointer code before I really understood what I was doing, except the ""segfaults"" occur at compile time instead of runtime. Progress!)<p>(Perhaps ironically, I'm finding it's making me better with OO, too. Expressing responsibilities in terms of methods that take closures, rather than simply ""concrete methods"" that take parameters that aren't closures, can be a remarkably powerful way to approach OO interfaces.)<p>I hope this doesn't sound mystical, because I don't really mean it to be. I suspect (and my gut says) that in the end this will not be particularly different than learning about pointers, and few people (though not zero!) consider learning about pointers a mystical experience today. But that learning takes time, and I've only begun. At something like ~12 years of serious experience, finding a paradigm like this that has left me feeling like a total newb again has been a bit of a shocker. I find it invigorating and interesting, but I have slightly greater understanding for those who feel like after that long they should be allowed to avoid stepping into the areas that make them feel like newbs...<p>(And also, for those who may read this who are considering Haskell, let me again emphasize that you can do a lot of work in Haskell without giving thought one to the issues I raise here. Just as you can be a pretty decent programmer without really getting into assembler, and pulling the state monad out of the library and using it is trivial. It's just that if you want to go in really deep and really understand what's going on, there's definitely different stuff going on. It's not just C, C++, or Perl writ different like most languages today.)",1266638109
1138589,comment,1136998,1138561,0,0,mbrubeck,,,"Fixed-point combinators are useful for memoizing or otherwise modifying recursive functions: <a href=""http://matt.might.net/articles/implementation-of-recursive-fixed-point-y-combinator-in-javascript-for-memoization/"" rel=""nofollow"">http://matt.might.net/articles/implementation-of-recursive-f...</a>",1266637655
1138588,comment,1138536,1138536,0,0,akkartik,,,"Was there one in the bay area?",1266637587
1138586,comment,1138149,1138149,0,0,fdschoeneman,,,"For those of you clicking on this link who haven't yet looked at Michael's tutorial, it's excellent.  I'm not a developer, know no languages other than a bit of html & css, and still had a fun time getting through chapters 1-4.  Michael is a very good writer (check out RailsSpace) and has spent a lot of time thinking about the best way to teach.<p>RailsTutorial, like Ruby and Rails, just feels right.<p>-- Fred",1266637337
1138585,comment,1138280,1138456,0,0,algorias,,,"See gunroar for an example of an incredible flow experience in a videogame.<p>I often play it to distract my body while working out algorithms. It's a surprisingly effective way of thinking through hard problems.",1266637265
1138584,comment,1138110,1138110,0,0,csmeder,,,"Am I understanding this correctly,  Intevydis sells exploits to people who want to make bot nets?",1266637211
1138583,comment,1137818,1137899,0,0,andrewljohnson,,,"Really? The OKCupid posts were some of my favorite articles on HN in a while.<p>I wonder if it's you who is marked as a spammer somehow, as opposed to the OKCupid blog.<p>I can't imagine why someone would want to blacklist that site, but I could imagine HN's capricious, opaque, oft-changing spam filter could have nailed you personally for no reason at all.",1266637200
1138582,comment,1136688,1137237,0,0,gorbachev,,,"Great advice.<p>In your calculations just remember though that salary and equity are taxed quite differently.",1266637140
1138581,comment,1138360,1138360,0,0,ryanelkins,,,"What exactly would you be trying to get out of this school? Define what ""a school for hackers"" means to you.",1266637083
1138580,comment,1138269,1138539,0,0,IgorPartola,,,"The problem with OSS is that you have to contend with some sort of a community. With WordPress you will open up the source code, throw up in your mouth a little, get the urge to patch things up and realize that your changes will never make it upstream. WordPress works. That's why it's so popular. It's easy to install, much easier to use than a lot of web publishing platforms out there and there are lots of ""useful"" plugins. Most of all, it's got the ubiquitous support: LAMP is the de facto standard for cheap hosting out there.<p>However, it does some things that keep me up at night. It stores serialized PHP arrays to define what users have access to (the MU branch). It strips away magic quotes based on runtime configuration, only to add them right back using a PHP loop. It does not use any form of output buffering. It's themes are PHP files that often times contain core business logic (somewhat of a PHP problem really, but still). WordPress is bad code and there is nothing anybody can do about it.<p>This of course is not true of all OSS projects: far from it. Just so happens that when a small community controls core development and the initial codebase is not great, which is the case with many early PHP projects, the outcome is that the code will stay bad.",1266637077
1138579,comment,1138257,1138521,0,0,thinkcomp,,,"Yes. I've been writing about taxes for a long time, actually. See<p><a href=""http://www.huffingtonpost.com/aaron-greenspan/new-deal-20_b_142518.html"" rel=""nofollow"">http://www.huffingtonpost.com/aaron-greenspan/new-deal-20_b_...</a><p>What you're supposed to do is bring problems to light through the press and/or lobbying Congress (the lobbying process is not just reserved for corporations) and/or filing lawsuits. When and where appropriate, I've done all three.<p>What you're not supposed to do is physically harm those you disagree with. That's the difference between a democracy and a dictatorship ruled by thugs.",1266637007
1138578,comment,1138269,1138506,0,0,lpolovets,,,"Interesting. Maybe this a reflection of how engineering quality doesn't matter compared to network effects, usefulness, trendiness, etc? As in, it's not that most successful web apps are not well-engineered, it's that most web apps in general are not well-engineered, and the successful ones are almost randomly distributed among the entire set.<p>I could see how bad engineering isn't too bad for product success, because once you have a site that makes money, people will put up with working with crappy code and designs if they are paid enough (well, not everyone would put up with this, but there are enough people that would, and enough money to pay those people..)",1266636960
1138577,comment,1138195,1138195,0,0,cdibona,,,"I thought open letters came after closed ones :-) Seriously, the merger just closed, we're only just starting the integration of the two companies.",1266636830
1138576,comment,1137458,1137458,0,0,p_coster,,,"A parallel version of burstsort is the topic of my honours project due in a few weeks. It's WAY faster. :P",1266636767
1138575,comment,1138099,1138099,0,0,defen,,,"Fascinating. I was hoping they would explain Typographical Number Theory though.",1266636754
1138574,comment,1138178,1138178,0,0,kirse,,,"Happiness is really a subjective and uniquely learned process for each person... Everyone has a different set of assumptions, expectations, and mental processes they have to deal with, usually all of which have to be overcome on some level to be truly ""happy"".<p>For most people, being engaged in work gets them to that state of living in the present, where the mind is fully focused on a task and doesn't get a chance to explore itself.<p>For me though, being truly happy is being able to relax in that free time, soak up the present ""nothingness"", allow the mind to wander, take everything as it is (without judgment or assumption), and just be grateful for everything I've been blessed with (even if there are negative circumstances).",1266636591
1138573,comment,1138528,1138528,0,0,noelchurchill,,,"This is the saddest thing that's ever made it to HN",1266636581
1138572,comment,1138280,1138508,0,0,kimfuh,,,"So you time flow? Doesn't it make more sense to let flow flow?",1266636538
1138571,comment,1137818,1138121,0,0,invisible,,,"I thought the same thing, but there isn't enough data to suggest that it's wrong.  I think that there is a portion ""unemployed"" a portion ""changed careers"" and a portion that are too small to individually plot.  So that entire graph may only be like 75% of those that were originally at those companies.",1266636531
1138570,comment,1137679,1138380,0,0,petewarden,,,"Nothing is wrong with it except that most of the damage was caused by the genius idea of adding gases to the atmosphere that basic physics tell us trap heat, in a world where people love to live in low-lying areas next to bodies of water, and then neglecting to worry about any curbs on this massive experiment in 'what happens next?'",1266636506
1138569,comment,1138481,1138559,0,0,plinkplonk,,,""" think people are looking for something profound where there really isn't anything as profound as they are imagining. ""<p>I largely agree with what you (jrockway) say, but differ in some nuances. These ""concepts + laws"" seem to be best understood  as mathematical constructs (like say functions or sets) than analogies. What I think is happening now is people are trying to understand Sets by studying say java.util.HashSet, or even worse, analogies to java.util.HashSet.<p>""Functors are containers that can apply a function (""fmap"") to their contents.""<p>This is true enough, but it is hard to understand the  ((->) r) functor (for example) as a container. You <i>can</i> do it but you have to stretch a bit. I have seen people struggle with understanding IO as a container.<p>Wheras if you know that a functor maps (or transforms) objects (in the cCategory Theory sense, not in the OO sense) to objects ,and morphisms to morphisms, subject to  3 laws, then it makes perfect sense that  ((->) r) is a functor. Likewise with IO.<p>The key this is to understand the Hask category where types are objects and functions are morphisms.<p>For a Haskell functor, the type constructor takes care of the ""objects to objects"" (or type to type) mapping and the first order function (map for lists for example, or compose for the  ((-> r) and so on)  take care of the morphism to morphism (here, functions  to functions) mapping.<p>And it is not even very hairy math. The definition of a category is hardly half a page of prose, much easier to understand than  some specs we programmers work off of.<p>@jrockway, do you want to write that book? :-)",1266636308
1138568,comment,1138481,1138559,0,0,tel,,,"Reading the Typeclassopedia is a great way to hear this all over again slightly different and is therefore highly recommended.<p>Really the biggest step is, as jrockway says, to realize that Monad is (kind of) a verb. ""Here's a list and here's how you can monad it.""",1266636253
1138567,comment,1136465,1136503,0,0,zwoop,,,"If you do, come join #traffic-server on freenode, the ""installation"" is still a little rough in the edges.",1266636198
1138566,comment,1138002,1138086,0,0,jsdalton,,,"If you make the switch, you might want to investigate this library: <a href=""http://documentcloud.github.com/underscore/"" rel=""nofollow"">http://documentcloud.github.com/underscore/</a><p>""Underscore is a utility-belt library for JavaScript that provides a lot of the functional programming support that you would expect in Prototype.js (or Ruby), but without extending any of the built-in JavaScript objects. It's the tie to go along with jQuery's tux.""",1266636020
1138564,comment,1138481,1138560,0,0,plinkplonk,,,"""The advantage of HN is that you get better comments than you would directly on your blog. Feedback++.""<p>Oh I agree. HN has the quality of having awesome comments and discussion on very bland  subject material.<p>I am just faintly embarassed that something that was just me rambling in prose landed up here.",1266635933
1138563,comment,1138535,1138535,0,0,aresant,,,"Right idea!",1266635904
1138562,comment,1138514,1138556,0,0,vog,,,"Unfortunately, it's not just a hook. It's a whole new repository clone just to maintain a checked-out working copy. The whole synchronization process between them is simply unnecessary.<p>BTW, in Mercurial it is indeed just a hook. And in Darcs even that hook isn't needed.<p>And FWIW, Mercurial can handle bare repositories, too.",1266635835
1138561,comment,1136998,1136998,0,0,Panoramix,,,"That's kind of beautiful. Non-programmer here, so can somebody point me to an application of these beasts? can I use this kind of thing to e.g., speed up something? 
Not that it would have less merit otherwise. Stretching my brain is already nice in itself.",1266635818
1138560,comment,1138481,1138549,0,0,jrockway,,,"The advantage of HN is that you get better comments than you would directly on your blog.  Feedback++.",1266635666
1138559,comment,1138481,1138481,0,0,jrockway,,,"<i>What we really need is an ""Advanced Haskell"" book which assumes a knowledge of Level 1 Haskell and then lays out the CT bits in an orderly fashion. Monads for example, are best understood from a Category Theory perspective than through some tortured analogy to Space Stations or Elephants or whatever.</i><p>I think people are looking for something profound where there really isn't anything as profound as they are imagining.  Monads are applicative functors with ""join"".  Applicative functors are functors with ""ap"".  Functors are containers that can apply a function (""fmap"") to their contents.  Add in some laws, and that's what you have; a few very generic concepts that let similar things have the same API.  There is nothing more profound here than any other generic API, except that the ""genericness"" goes beyond what most programmers are used to.  (Most programmers seem to be used to abstractions that take some ""noun"" and make variants -- map => hashmap, alist, plist, binary tree; list => linked list, vector.  Haskell's abstraction is more like an adjective -- a functor isn't really a thing that you can hold in your hand, it's just a property of something.  ""Monad"" is a property of ""list"" like ""red"" is a property of ""apple"".)<p>(Monoids are even more generic -- they are something that has an ""identity"" and an ""append"" operation.  Lists are monoids, but so are booleans like ""Any"" and ""All"", and integers form monoids over addition and multiplication.  Monoid is just a word that relates the common properties.  The advantage of this abstraction in Haskell is that you can ""mconcat"" a list of sentences into a paragraph just like you can ""mconcat"" a list of numbers into their sum.)<p>Monads get a lot of mindshare in Haskell because they are a good way to sequence computations -- you write a single sequencing combinator, and you get convenient syntax sugar and a big collection of utility functions (""liftM"", etc.).  Write another function, and you can create monads from other monads, which happens to be convenient for writing applications.  (Reading the definition of the type ""X"" in xmonad is enlightening, if only because you realize that the entire program is a bunch of functions that return ""X"", and that the mechanics of X's ""monad"" instance make the program work the way it does.  xmonad is really the X monad!)<p>Arrows are like monads, except instead of ""bind"" you have a variety of other combinators; ""fanin"", ""fanout"", etc.  If your data flow looks like that, Arrows make your code look like your dataflow.  (And from a category theoretic perspective, every monad is an arrow.  Kind of how every ""light red"" is ""red"".)<p>I think RWH provides good coverage of monads, although reading RWH once you ""get"" monads can be tedious.  The good news is, by the time you learn what the word ""monad"" means, you already know what it does for you.<p>So anyway, just start programming, and you'll see why these abstractions are useful.  You'll also see why ""easy to understand"" abstractions like ""foldable"" and ""traversable"" are useful too, even though there is not much category theory there.<p>I guess to summarize: don't let unfamiliar words scare you away from simple concepts!  You already know how to program, and programming Haskell is just programming!",1266635639
1138558,story,,,1,0,ryanelkins,"Advertising vs Marketing vs Public Relations vs Branding",http://blog.chasejarvis.com/blog/2010/02/who-says-youre-great-lover.html,,1266635609
1138557,comment,1137646,1138245,0,0,Herring,,,"If you somehow got Windows source code into your program, you couldn't distribute it without getting sued. If you liked FUD, you could say the Microsoft license (do not distribute without MS permission) has spread to your code. That's just how all licenses work. If you don't agree to the terms, don't use the code.",1266635544
1138556,comment,1138514,1138551,0,0,cookiecaper,,,"I guess I don't know how it works on hg or darcs, but I appreciate the bare repositories and git's reluctance to push on top of a checked-out working copy. It's not too hard to add hooks that make things automatic if one is so inclined, as we see in this case.<p>As for me, I just type the extra ""git pull"" or ""git push"". It's not a big deal for my use case right now, though if it were I know it's fairly simple to add hooks that automatically pull changes into your running copy (""Prime""), though I'm not sure I want that. I like pushing to the hub and controlling when those changes get rolled out without having to maintain a ton of different branches.",1266635488
1138555,comment,1136733,1136903,0,0,metajack,,,"Because for venture-backed companies, becoming wildly profitable is only one of several possible exits. Acquisition, IPO, and bankruptcy are the most common other exits.",1266635413
1138554,comment,1138269,1138506,0,0,dschobel,,,"It's certainly a counter-intuitive and pervasive phenomenon but maybe the fact that so few social platforms ""make it"" should keep us from drawing any real causal conclusion beyond the fact that technical competence is neither necessary nor sufficient for success.",1266635412
1138553,comment,1137669,1137875,0,0,lsc,,,"text of the law:
<a href=""http://www.synergistech.com/1706.shtml"" rel=""nofollow"">http://www.synergistech.com/1706.shtml</a><p>the problem is that it's pretty unclear how to avoid violating it.",1266635317
1138552,comment,1138178,1138178,0,0,og1,,,"I don't agree with this. Maybe the pager influenced their state of mind. I know whenever I get interrupted when I'm doing something enjoyable it makes me annoyed. And vice versa, whenever I'm doing something boring, I'm glad to be interrupted. Maybe that is what was happening in the pager experiment.",1266635204
1138551,comment,1138514,1138514,0,0,vog,,,"If ""git push"" would work properly for non-bare destinations (as it is the case with e.g. Mercurial and also Darcs), the design could be simplified by merging ""hub"" and ""prime"".",1266635185
1138550,comment,1137669,1137750,0,0,lsc,,,"or they are individuals with a high risk tolerance.",1266635113
1138549,comment,1138481,1138481,0,0,plinkplonk,,,"I don't think this is HN material (I wrote the blog post,I didn't submit it). This post is just me ""thinking by writing"", trying to clear my head.<p>I thought  it was a largely content free post, just some rambling, and yet here it is on HN. Slow news day I imagine! :-P.<p>Here is a summary, to save you time - Haskell needs a book (to complement RWH) focusing on the the Category Theory aspects.",1266635111
1138548,comment,1138266,1138435,0,0,beamso,,,"I just went to youtube in the default browser on my Maemo phone.  The flash plugin is installed, but Mozilla are ignoring it in the Firefox for Maemo because of all the crashes.",1266635076
1138547,comment,1138069,1138258,0,0,cookiecaper,,,"Hmm, well, this is different I think. Most jailbreakers aren't doing it so that they can violate copyright and use apps without the consent of the rights holder, most jailbreak so that they can install apps from non-approved sources, use the phone on non-approved networks, and gain extra leverage over the device (SSH, etc.).<p>To me, that just sounds like doing what you want with a device you own, and telling Apple that you appreciate the sentiment but don't need their babysitting.<p>When you download a movie or a game from an unauthorized source, that's copyright infringement. When you download an exploit that lets you use your phone in the ways you want, that's just downloading an exploit; it doesn't transmit any substantial intellectual property owned by any other party, so I don't understand your complaint or comparison, really.<p>The one provision which jailbreaking may violate is the DMCA's restriction on circumvention of ""copy protection"". Technically, sharing any mechanism to circumvent ""copy protection"" is illegal in the United States. I don't think that jailbreaking qualifies as a circumvention of copy protection on balance, though, because most people aren't doing it to make copies, but of course that depends on the judge.",1266635060
1138546,story,,,39,13,razerbeans,Boreout,http://en.wikipedia.org/wiki/Boreout,,1266635047
1138545,comment,1138360,1138360,0,0,subud,,,"Are you talking about a virtual school or a real physical school?",1266635027
1138544,comment,1137337,1137909,0,0,endtime,,,"Sure, but that's completely irrelevant.  You're not making a coherent point.<p>Microsoft doesn't have a browser monopoly.  Period.",1266634991
1138541,comment,1138280,1138456,0,0,patio11,,,"Continuing on the theme of building game mechanics into our projects... couldn't we do this if we wanted to?<p>Post-deploy hooks are available for your source control system of choice.  You could have your computer tell you ""Nice job"" for one commit (if automated tests pass), ""Keep it going!"" for two in an interval, ""He's on fire!"" for three, ""BOOM that's amazing!"" for four, etc etc.  This would incentivize yourself to do ""just one more commit"", in the same fashion as Civ and whatever get ""just one more turn.""<p>(If doing it over a work day wasn't working for you, you could bump the visualization to your dashboard and create a chain, with one link for every day you do task X.  Don't break the chain, as per Seinfeld.)<p>This assumes, <i>critically</i>, that a commit is a measure of forward progress towards business goals.",1266634815
