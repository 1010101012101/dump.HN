ID,Type,Story,Parent,Points,Comments,Author,Title,URL,Content,Created
33259,comment,33246,33252,0,0,tuukkah,,,"Ruby and C++ both have a complex syntax, nevermind that being superficial. The LFSP example in the article was Ocaml, which doesn't even have operator overloading! What makes Ocaml an LFSP - the little I know about it - includes a nice combination of FP and OO plus a powerful type system.\n",1183996689
33258,comment,33249,33249,0,0,donna,,,"The bizdev strategy he points to has always confused me in it's logic.  Maybe I'm too conservative, maybe going for the big vender is sales diversification.  What would the math look like re costs vs. returns over 2 years w/a team of 4, and with the IBM like vender buy out?",1183996591
33257,comment,33246,33251,0,0,nostrademons,,,"Unfortunately, interfacing multiple languages is itself not a strategy for LFM-people, because most of them can (or <i>believe</i> they can) only fit one language into their brains.  There are costs to using more than one language on a project.    Managers frequently overestimate these costs, because they're the ones who will look bad if their superior (or investor) looks at their development process and say ""Wow, this is chaos.  No wonder you can't ship software.""<p>There does seem to be a loophole: you can use multiple languages if they all start with the same buzzword.  So, the same manager who balks at a Python/C++/SQL solution because it uses too many languages has no problem requiring that his developers learn Java, JavaScript, Java Server Faces, Java Persistence Query Language, Java Expression Language, and the Java Standard Tag Library, because they all start with ""Java"".  Same goes with XML/XSLT/XSLFO/XPath and derivatives.<p>Based on this observation, I suggest a renaming of all common hacker tools.  Python should be renamed ""ParrotSnake"", Ruby ""ParrotGems"", Lisp ""ParrotParens"", SQL ""ParrotQueries"", JavaScript ""Parrot in a Browser"", HTML ""ParrotTags"", Haskell ""ParrotMonads"", and so on.  Then we could freely use any of these on a project, because they're all the same language, duh.  Of course, the Parrot project itself should be canceled, because it'd defeat the purpose to have them <i>actually</i> running on a common VM.  This is strictly a marketing initiative.",1183996486
33256,comment,33246,33254,0,0,aston,,,"I think you missed part of my point, which is that ""..."" vs. "".."" is a subtlety introduced by the mantra of high-density syntax seen in LFSP design.<p>The 10 doesn't print, btw.",1183995911
33255,story,,,1,1,far33d,"Passive-Aggressive Behavior Is Useless In A Startup",http://www.feld.com/blog/archives/2007/07/passiveaggressi.html,,1183995784
33254,comment,33246,33252,0,0,brlewis,,,"The only reason I can think of why someone would look at the Ruby code and not be immediately sure that the 10 prints, is if they've become very accustomed to for loops like the one in the C++ example.  It's conditioning, not intelligence, that makes the difference.",1183995169
33253,story,,,1,0,Tichy,"Where to best track positioning in search engines (by keyword)?",,,1183995028
33252,comment,33246,33250,0,0,aston,,,"One of the features of LFSP's is that the code density is higher, which I'd argue is a good way to make the code harder to read, not easier.<p>Here's an example in ruby:<p><pre><code> (1...10).each{ |x| print x }\n</code></pre>\nTell me, does the 10 print or not? You'll need a second glance plus a good memory to answer that question.<p>Here's the same code in C++:<p><pre><code> for (int x = 1; x < 10; x++)\n   cout << x;\n</code></pre>\nVerbosity makes it easier for the non-you programmer to look at a random piece of code and decipher it. You feel smarter for having written that Ruby code (and the C++ is boring, I'll agree). But I'm gonna have to say the Ruby code has less readability outright just because it's so dense.",1183993792
33251,comment,33246,33246,0,0,tuukkah,,,"To get wider use of LFSPs, it would be important for more people to learn that you <i>can</i> and it's completely <i>reasonable</i> to interface several programming languages. You need to be comfortable with both languages to work on the interface, but I find it surprising we didn't practice this at school at all.<p>To explicate what the article touches: Perhaps you really have to use Java because of platform or workforce requirements, but it doesn't mean you have to use 100% Java. More experienced developers can build some of the low-level classes using C++ via JNI. They can also set up BeanShell or Jython for user interface and test scripters.\n",1183993426
