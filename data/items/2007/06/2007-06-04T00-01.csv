ID,Type,Story,Parent,Points,Comments,Author,Title,URL,Content,Created
26186,comment,26120,26120,0,0,Darmani,,,"This slide show seems to be more of an effort to distort common and well-accepted applications of motivational psychology as originating from games. Of the five game mechanics listed, probably only one (points) originated in games: I collect every time I go to the grocery store, receive feedback every time I touch a hot stove, make an exchange (almost) every time I speak, and customize every time I go to a restaurant and ask for chicken instead of turkey. You could probably absorb these lessons as applied to software a lot better by analyzing the reinforcers present in EBay and the other sites mentioned than by thinking of games.<p>There's probably a lot more to learn from what I expected this article to be: An in depth discussion of how game theory applies to web applications.",1180918678
26185,comment,26150,26150,0,0,aston,,,"Based on your replies to my comments so far, I think you're still missing the point. You've implemented good functionality, but you don't have a product. You need to figure out a way to convey why someone would want to use your site and make it easy for them to do so without being confused.<p>For example, I now know what the import/export options do, but there's absolutely no reason for those to be on the front page. I'm not even logged in, so they have zero relevance to my experience. Even for a registered user, they should probably be tucked away under ""Advanced"" or under some options tab. It's functionality only the techiest of techies would care to use; in general we can trust that you'll keep our data safe and we won't need personal backups. And working on your ""heuristic import"" is not a good idea either. It's your format, no one else is using it, so just make it simple and parse it in and out. <p>Your users couldn't care less how cool your code is or how many features you've implemented, just make something useful and make it easy to understand.
",1180918664
26184,comment,26150,26164,0,0,aston,,,"I'm saying you could have (more easily) just let a new page load. Then javascript wouldn't be a requirement, and if I wanted to control the loading of the page I could do it with my browser controls.",1180918350
26183,comment,21795,22496,0,0,BitGeek,,,"
Sigh.  Confusing correlation with causation is exactly the kind of foolish error that I'm talking about. <p>I think its a very childish response to accuce me of being angry or jealous because I have a different opinion, tht is strongly held.   <p>But its simply dishonest to put words in my mouth like that.   <p>I have not made claims to be great, and I have not said my methods are superior to facebook... nor have I said anything derogatory about YC, especially when YC funds college age students-- I think the college age generation are the perfect candidates for the YC program. <p>Its really quite sad that you have demonstrated exactly the errors I am pointing out in facebook in your defense of them-- you have reacted in a narrow minded and judgemental way-- attacking me personally, rather than the position I have taken.   This kind of political correctness is exactly what Facebook is doing when they don't hire people based on skills, but based on other factors such as age and, well, ideology.<p>Further irony comes from you attacking my skills when I have not relied on argument based on my ""superior"" skills, and further, what skills do you have?  Not that they would be relevant-- but if you had sufficient skill you should be able to make a counter argument based on the state of the art and advanced techniques.  In short, by attacking me, you show you do not understand the technology well enough to make a technological argument, ironic since technical skill is where you criticized me.<p>Even saying I'm jealous is a childish pathetic personal attack on my skills.<p>Anyway, for the past 20 days I've been off doing... and you'll notice I have no posts here in that time period.   Meanwhile you have made 28 comments here in just the last 3 days.<p>How's <i>your</i> startup going?",1180918190
26182,comment,25936,26147,0,0,SwellJoe,,,"What do you believe would be the obvious choice for a web-based application that administers everything on a UNIX system?<p>Keep in mind:<p>It runs as root.<p>Directly parses and edits every configuration file that is managed--this is not a ""generate config files from a database plus templates"" tool--it has to understand the configuration files and edit them cleanly.  Strong regex support is vital.<p>It is internationalized to dozens of languages...it needs to support Unicode.<p>It has to be reasonably fast...it serves dozens of users simultaneously, often doing rather complicated tasks.<p>It needs to be a widely available and stable language--we support dozens of platforms (nearly all Linux distros, Mac OS X, the BSDs, and even Windows to some degree).  All of them have different versions of Perl, Python, Ruby, PHP etc. and varying degrees of library support ""out of the box"".  We need to know that whatever reasonably recent version exists will work fine now and in the future.",1180917800
26181,comment,25936,26067,0,0,SwellJoe,,,"Several reasons:<p>The most compelling, and inarguable, being that our codebase is approaching ten years old (Webmin, with about 300k lines of code, is the core of our product).  Ten years ago, Perl was the clear choice for web applications and system administration applications, so it was a double win.  Several ""competing"" Open Source and proprietary products in other languages, including Python and PHP, have come and gone during that time, and we expect more to come and go in the future.  Re-writes of a large codebase merely to follow language fashion are idiotic, and we're not idiots.<p>Jamie and I have frequently worked in other languages, with Python having been used heavily by both of us.  I'm a bit of a language geek and so I spend a few days every month with something new (I'm playing with Haskell right now).  We're not Perl-only developers, but in hindsight Perl has served Webmin very well, and it continues to do so.  It has some very nice functional constructs that make the kinds of data processing we do simple and short...we make heavy use of map, grep, first class functions, etc. and it's possible to treat Perl arrays like Lisp lists, which can be very powerful.  We'll both admit to liking Python syntax.  We might even admit to liking it better than Perl, after we've had to dig into one of the older modules in Webmin and interpret some of the squiggles Jamie used back then.  I definitely like Ruby syntax better.<p>But, although I've said that we aren't Perl-only developers, it is worth mentioning that Jamie (the primary developer on all of our products) is fantastically proficient with Perl.  It's a language he's been working with full-time for his entire professional career, and it shows.  He can produce, in hours, what I've witnessed other projects spend weeks or months creating badly.<p>Perl is extremely expressive, quite concise, is fast enough for almost everything we do, has great Unicode support, threads and concurrency that works, and an extremely mature and stable implementation.  We can count on our software running on just about any recent or future version of Perl.  This is not true of Python, Ruby, or PHP (with PHP being the most egregious example of backward-compatibility failure--I've done enough work in all three to know that Perl wins hands down in this area).  Java is pretty stable, but would require a lot more code, and it isn't as widely available on Linux systems.<p>""close ties to shell scripting"" doesn't really play much of a role, though the close ties to system administration does.  Perl evolved out of system administration and text processing tasks, so it has a lot of great features for those tasks.  As mentioned, Perl's grep is great for that kind of job, as are map, split, etc.  It's nice to have iterators that already exist for the exact tasks we're doing.  Sure, we could write our own in other languages (assuming they have the constructs needed to do it cleanly...so Python and Ruby,  but probably not PHP), but we don't have to in Perl.  I've worked on system administration tools in Python in the past, having modified yum, trac, Subversions post-commit mailer.py script, and Mailman for various custom tasks, and I generally come out the other side thinking, ""I could have done that faster, and cleaner, in Perl"".  This reflects my own weakness in Python nearly as much as the strengths of Perl over Python, but I don't believe it is entirely my lack of proficiency.  Perl just does some things better, and system administration is one of them.<p>I'm actually in the midst of choosing a language for new hosted applications, and so I'm thinking a lot about whether to stick with Perl or branch out some.  We are no longer really tied to Perl--even with things that go out to customers--as Webmin has an XML-RPC interface, which can be used from any language with reasonable support for XML and sockets (pretty much all modern languages).  But for hosted apps we're entirely free to choose.  So, the UI portion of it will be implemented in PHP, to ease integration with our Joomla-based website...since I thoroughly dislike working in PHP, the other components of those apps will be in another language...probably Perl, but I'm toying with Erlang and Haskell.  We'll see.<p>In short, saying ""Perl, really?"", kind of indicates a bias against Perl that is unjustified.  Sure, many have trouble with the syntax.  It can be intimidating.  I've been working with it for years, and I generally can't write more than 10 lines without a syntax error!  And, much Perl code in the wild is ugly...even some of Webmin's older code that we have to work with (and some of the newer code that I write that Jamie hasn't fixed yet!).<p>But, it's among the most powerful mainstream languages.  Because the folks making decisions about Perl don't have Guido's or Matz' devotion to one particular development model, Perl gets everything--every cool idea in software development ever thought of has an implementation in Perl.  You can code entirely in a functional style in Perl.  You can do OO.  You've got first class functions and closures.  TMTOWTDI is a double edged sword, we can all agree, but if used wisely, it cuts through an awful lot of crap really fast.  ;-)",1180917457
26180,comment,26088,26088,0,0,lupin_sansei,,,"""Evan says:
 Maybe it goes without saying, but I think it's reasonable to say that what people consider ""basic everyday functions"" have evolved enormously. For many people, ""everyday functions"" now includes: storing, finding, and sharing every peice of music I own, every photo I take, and every home video I shoot. Plus keeping in touch with all my friends, by multiple channels including voice chat, possibly simultaneously. While watching streaming video of last night's ""Heroes"" while downloading a few hundred Megs of files.  """,1180917022
26179,comment,26134,26174,0,0,machine,,,"I agree with tx.  With C++ you can often avoid what would be virtual method calls in Java / if statements in C by using templates.  This lets you effectively inline every function call.  It'd be hard to do this in a clean way in C.",1180916928
26178,comment,26135,26135,0,0,lupin_sansei,,,"I never realised how much Ghostscript (PS?) looks like Lisp.",1180916701
26177,comment,26116,26169,0,0,machine,,,"I disagree with you on a lot of points.  First, I don't think AI has failed to deliver.  There are a ton of things we can do now that we couldn't 30 years ago.  Just to name a couple, how about simultaneous localization and mapping <a href=""http://web.mit.edu/16.412j/www/html/readings/Eliazar+Parr-ijcai-03.pdf,"" rel=""nofollow"">http://web.mit.edu/16.412j/www/html/readings/Eliazar+Parr-ijcai-03.pdf,</a>
and face detection 
<a href=""http://citeseer.ist.psu.edu/viola01robust.html."" rel=""nofollow"">http://citeseer.ist.psu.edu/viola01robust.html.</a>  <p>I also disagree that AI researchers are working on boring narrow problems.  There are plenty of researchers working on huge open problems like object recognition, speech recognition, reinforcement learning, etc.  And they're making great progress too.  I think the reason most AI researchers don't talk about making ""human-level AI"" is that this isn't really a quantifiable goal.  There are plenty of things computers can do better than people already (would you want a computer with ""human-level"" addition and subtraction?).  And for just about every specific useful task humans do better than computers, there are a few dozen AI researchers working on it.  Why is that not a reasonable approach to the problem?",1180916373
