ID,Type,Story,Parent,Points,Comments,Author,Title,URL,Content,Created
28009,comment,27972,27993,0,0,bootload,,,"<i>'... this stigma now that it's all about the hackers and that business guys are nothing but dead weight ...'</i><p>In the tech startup world this is pretty close to the truth in small companies. In larger ones,  where business types have places to hide from <i>bully</i> hackers, it's the other way around.  The thing that comes to mind is if you can't understand technology it makes it harder to grasp the opportunities. It's hard enough as it is. I can think of only a few business MBA's <i>who have</i> created & run successful startup tech companies. (Donna Dubinsky, of Palm is one that comes to mind). There's a good article on <i>""OnStartups, You Don't Need A World-Class Management Team""</i> about why management aren't needed ~ <a href=""http://tinyurl.com/35dmlz"" rel=""nofollow"">http://tinyurl.com/35dmlz</a><p>But why concentrate on just startups? What about other examples of non-tech <i>entrepreneurs</i> that strike out?  One that comes to mind is Shawn Nelson of LoveSac fame who saw the combination of retro 70's spirit + emerging Chinese manufacturing and a gap in the furniture market and a new company was born.  ~ <a href=""http://www.lovesac.com/lovesac/history.php"" rel=""nofollow"">http://www.lovesac.com/lovesac/history.php</a><p>The irony of <i>'outsourcing management'</i> in startups is not lost on me.",1181796674
28008,comment,27875,27928,0,0,mdakin,,,"I don't want to come across as anti-unit-test or anti-studies but I suggest you run your own study and gauge your own performance rather than assuming you and your team perform as an average team does.  <p>Thanks to the version control tools we use this is easy.  Adopt a policy where you commit code for a SINGLE reason at a time.  Enumerate a few standard reasons such as BUGFIX, FEATURE, FEATURE_AND_UNIT_TEST, REQUIREMENTS_CHANGE, UNIT_TEST_MAINTENANCE.  Estimate the engineering time that was spent on making the change.  Log that duration.  Periodically analyze your performance and see for yourself how much time unit-testing is costing or saving you.",1181796384
28006,comment,27674,27674,0,0,awt,,,"Doesn't really say anything about startups...",1181795694
28005,comment,27864,27864,0,0,awt,,,"That guy is hard to watch.  He really needs to get to the point.",1181795494
28004,comment,27475,27538,0,0,mwseibel,,,"codeLullaby - looking for a job? we can always use a good hacker...  let me know michael@justin.tv",1181795077
28003,comment,27890,28001,0,0,amichail,,,"Unless the other one already has a lot more users.",1181795056
28002,comment,27875,27875,0,0,dhouston,,,"it depends, and in my experience can be reduced to a cost/benefit analysis. a sprinkle of different things has worked for me -- some things to think about:<p>what's the impact of a typical bug in your app: an error 500 page (annoying) or a BSOD or corrupted data (much worse) or a missile hitting a house? these will merit different levels of testing rigor.<p>if something is breaking, how do you even know? how much time will have elapsed? how long will it take you to find the cause, and is suitable debugging information available for your investigation? how quickly can you come up with a fix, and how expensive is it to deploy it? this is, in my experience, a <i>much</i> more effective place to optimize if you're a web app, especially if you're a small team.<p>for the non-core pieces of a web app, i'd rather release twice as fast and have logging and monitoring infrastructure in place to find and fix problems quickly (e.g. exception - logged and SMSed to our cell phones) than spend 2x to write unit tests (and maintaining them later.) a nice property is that you'll tend to find bugs roughly in order of decreasing impact, or at least prevalence. however, this approach won't do much against silent failures or bugs that are both rare and high impact.<p>there are lots of other effective tools: automated smoke tests (by which i mean end-to-end tests that quickly test large pieces of the app) deliver a lot of bang for buck, and root out unintended consequences of seemingly local changes that even unit tests sometimes miss. i also find generous use of the assert keyword finds failures fast/nearer to the cause.",1181794587
28001,comment,27890,27988,0,0,staunch,,,"I think given two otherwise similar services the one that's fully functional inside Facebook will get more users.<p>",1181794547
28000,comment,27875,27888,0,0,jimbokun,,,"Wil Shipley on unit tests: <p><a href=""http://wilshipley.com/blog/2005/09/unit-testing-is-teh-suck-urr.html"" rel=""nofollow"">http://wilshipley.com/blog/2005/09/unit-testing-is-teh-suck-urr.html</a><p>I think what he's saying is unit tests don't add much if you are doing UI type development.  It is hard to write unit tests for UIs (web or GUI), so if most of your code is UI code, don't bother.<p>However, if you are writing a library that will be used by a lot of coders, unit tests are probably indispensable.  Otherwise, you would never be able to make even simple architecture or design changes (refactoring).",1181794138
