ID,Type,Story,Parent,Points,Comments,Author,Title,URL,Content,Created
1310234,comment,1308921,1309139,0,0,ErrantX,,,"Perhaps; but as a juror you are one of the most important people in our modern world. You have to help make a representative, moral and right choice about someones guilt.<p>I think it's fair to assess who is able to perform that task with minimum bias etc.<p>Then again does that make it truly representative? Should we test people for racist bias in the trial of a black person?<p>It's an interesting dilema.",1272697093
1310233,comment,1308281,1308281,0,0,kingsley_20,,,"for the real story on why non-flash web games matter, you have to look at ease of porting to mobile/smartphone/social network platforms. If you could write a game that had 50% of the richness of a flash game, but worked quite nicely on (highly monetizable) facebook and could be easily ported to the (highly monetizable) iphone, is that worth more to you than the richness and playability on IE?",1272696843
1310232,comment,1310207,1310207,0,0,maqr,,,"I know absolutely nothing about baby delivery, but I don't see how this could go wrong.",1272696704
1310231,comment,1308281,1308644,0,0,kingsley_20,,,"the mechanic in chains has a lot of potential. the implementation feels solid too!",1272696487
1310230,comment,1310105,1310223,0,0,barrkel,,,"But a loop that never exits will never continue on to the rest of the program, which will never have <i>its</i> side-effects.<p>This loop has no side-effects:<p><pre><code>    for (;;)
        /* do nothing */;
</code></pre>
So the compiler, according to the spec, can remove it, right?<p><pre><code>    for (;;)
        /* do nothing */;
    destroy_the_world(); /* has side-effects */
</code></pre>
So will the world be destroyed? Or is the following code dead? In which case, it's <i>not</i> OK for the compiler to remove loops that have no side-effects.",1272696436
1310229,comment,1310105,1310225,0,0,barrkel,,,"Reasonable has nothing much to do with it, IMO; and I'm not really talking about C (it is only an example), but about compiler optimizers.",1272696251
1310228,comment,1310221,1310221,0,0,apphacker,,,"I don't think using JavaScript to fix something CSS can't do is the proper solution. I think to draw a static width box around the variable width items or just not worrying about the flush on both sides (something you can accomplish with CSS if you're willing to use an extra container to wrap all items except the last.)<p>But styling via JavaScript because you couldn't do it in CSS? Yech. Especially if it's not some kind of UI component that needs JavaScript interaction like an accordion or drag handle or something.",1272696163
1310227,comment,1309576,1309576,0,0,blasdel,,,"I did a spit-take because for some reason in my head I'd gotten jeresig mixed up with this kid who did a Google Tech Talk on jQuery <i>when he was twelve</i>: <a href=""http://www.youtube.com/watch?v=8mwKq7_JlS8"" rel=""nofollow"">http://www.youtube.com/watch?v=8mwKq7_JlS8</a>",1272696148
1310226,comment,1308788,1310038,0,0,Zev,,,"I was simply referring to OS X's automated crash reporting tool. Which <i>does</i> work after a kernel panic, regardless of what messed up badly enough to cause such an event.",1272696051
1310225,comment,1310105,1310216,0,0,_delirium,,,"Yes, but in what vaguely reasonable circumstances would you write dead code whose deadness depends on the fact that an infinite loop precedes it? The fact that the C standard doesn't consider changing termination properties from nonterminating to terminating to be an impermissible optimization seems reasonably practical.<p>The only thing I can guess at would be something in embedded-land that's using nonterminating loops as some sort of control-flow construct.",1272695772
1310224,comment,1308282,1309101,0,0,aaronblohowiak,,,"installing node on your mac takes all of 5 minutes if you already have ports installed.  speed in development turnaround is important to me.",1272695696
1310223,comment,1310105,1310204,0,0,neilc,,,"<i>That an optimizer assumes without proof a solution to the halting problem for some sub-program would mean that it's an unreliable translator</i><p>The optimizer doesn't need to solve the halting problem for this example. It merely needs to prove that any iteration of the loop has no side effects; hence, an unbounded number of loop iterations also has no side effects, and the loop can be removed.<p>The real issue is whether termination is considered a side effect. The canon is the C spec; if you can point to some language in the spec that would prevent the optimization, I'd love to see it.<p>Update: on reflection, I think you're right. The point isn't that the loop has side-effects (it obviously doesn't); but by changing the termination behavior of the loop, the compiler is likely to induce additional side effects (when it runs the subsequent code).",1272695616
1310221,story,,,50,21,wheels,"The curious case of equidistant boxes, a CSS fail",http://blog.directededge.com/2010/04/30/the-curious-case-of-equidistant-boxes-a-css-fail/,,1272695592
1310220,comment,1309576,1310108,0,0,barnaby,,,"Me too. RIT is a fantastic school, arguably one of the best if you're going into technical domains like engineering or software.<p>Rock on!",1272695525
1310219,comment,1308282,1308602,0,0,aaronblohowiak,,,"if you use it for something unrelated, then set the unrelated thing equal to background_color, but keep them semantically separate.",1272695523
1310218,comment,1308282,1308592,0,0,aaronblohowiak,,,"and if you go to export as html/css you'll get something like this:<p><pre><code>  .primary-1 { background-color: #FFDDC2 }
  .primary-2 { background-color: #E5C9B4 }
  .primary-3 { background-color: #DAAA84 }
  .primary-4 { background-color: #FFEBDB }
  .primary-5 { background-color: #FFF6EE }

  .secondary-a-1 { background-color: #FFE6C2 }
  .secondary-a-2 { background-color: #E5D1B4 }
  .secondary-a-3 { background-color: #DAB784 }
  .secondary-a-4 { background-color: #FFF0DB }
  .secondary-a-5 { background-color: #FFF8EE }

  .secondary-b-1 { background-color: #FFCFC2 }
  .secondary-b-2 { background-color: #E5BEB4 }
  .secondary-b-3 { background-color: #DA9684 }
  .secondary-b-4 { background-color: #FFE2DB }
  .secondary-b-5 { background-color: #FFF2EE }

  .complement-1 { background-color: #C2FFFD }
  .complement-2 { background-color: #B4E5E3 }
  .complement-3 { background-color: #84DAD7 }
  .complement-4 { background-color: #DBFFFE }
  .complement-5 { background-color: #EEFFFE }</code></pre>",1272695391
1310217,comment,1310105,1310211,0,0,barrkel,,,"If you accept the grandparent's argument on face value, you should accept that a compiler should be able to remove other do-nothing infinite loops, like in the example I mentioned elsewhere:<p><pre><code>    for (;;)
        /* do nothing */;
    destroy_the_world(); /* has side-effects */
</code></pre>
Why should a compiler remove the loop in the OP's case, but not remove the loop above? Do you accept that removing the loop changes the side-effects of the program?",1272695384
1310216,comment,1310105,1310209,0,0,barrkel,,,"I find it somewhat difficult to believe we're having this conversation in any seriousness.<p>Consider this program fragment:<p><pre><code>    for (;;)
        /* do nothing */;
    destroy_the_world(); /* has side-effects */
</code></pre>
Would you say that a compiler that removed the loop changed the side-effects of the program?",1272695199
1310215,comment,1309269,1309269,0,0,cdnwebhosting,,,"cdnXite - <a href=""http://www.cdnxitehosting.com"" rel=""nofollow"">http://www.cdnxitehosting.com</a> - offer VPS Hosting with datacentre in UK/USA/SWEDEN. Just add Microsoft free CDN - <a href=""http://www.microsoft.com/windowsazure/windowsazure/"" rel=""nofollow"">http://www.microsoft.com/windowsazure/windowsazure/</a>",1272695169
1310214,comment,1309576,1310108,0,0,KingOfB,,,"Makes me proud(er) for having dropped out of RIT years ago ;)",1272695086
1310213,comment,1310105,1310206,0,0,barrkel,,,"The Halting problem is primarily practically useful in automated program analysis, of which the most common instance is compiler optimizers.<p>I'm loathe to reference Wikipedia as an authority, but it's even quoted there as part of a proof as to why compilers cannot optimize programs as much as might be possible:<p><a href=""http://en.wikipedia.org/wiki/Compiler_optimization"" rel=""nofollow"">http://en.wikipedia.org/wiki/Compiler_optimization</a><p><i>However, optimizing compilers are by no means perfect. There is no way that a compiler can guarantee that, for all program source code, the fastest (or smallest) possible equivalent compiled program is output; such a compiler is fundamentally impossible because it would solve the halting problem.</i><p><i>This may be proven by considering a call to a function, foo(). This function returns nothing and does not have side effects (no I/O, does not modify global variables and ""live"" data structures, etc.). The fastest possible equivalent program would be simply to eliminate the function call. However, if the function foo() in fact does not return, then the program with the call to foo() would be different from the program without the call; the optimizing compiler will then have to determine this by solving the halting problem.</i>",1272694992
1310212,comment,1308921,1309833,0,0,mburney,,,"Not sure why this comment was downvoted so much, it does a good job of summarizing an ancient world view which goes against our current scientific one. The ancient idea being that one's virtue is connected to one's vitality.<p>Topics like virtue, nobility, the body/soul have been misunderstood by modern science; these problems can't be solved with empirical evidence + deductive logic. The ancients thought about these things in a radically different way from us because they accepted that higher-level values are a matter of interpretation to be distinguished from lower-level factual (scientific) things.",1272694923
1310211,comment,1310105,1310184,0,0,gojomo,,,"The alternate behavior, while initially non-intuitive, seems more useful to me, in usual scenarios. And the grandparent post's taxonomy including the idea of ""partial correctness"" also seems useful. So you'll have to justify your ""<i>must</i>"" a bit more.<p>In particular: a programmer who wants an infinite loop can get one easily enough. Code that is complex, <i>and</i> has no side-effects other than affecting termination, <i>and</i> never terminates is likely to be a bug. As long as users of an optimizer know that it makes this choice -- that this particular pedantic kind of 'correctness' is waived in the face of otherwise side-effect-less code -- it seems an implementor's choice. And lots of competent implementors seem to have chosen the path you say they ""must"" not do.",1272694816
1310210,comment,1309403,1310118,0,0,dave1619,,,"Thanks, that's helpful.  I didn't know wordpress does affiliate links too.",1272694663
1310209,comment,1310105,1310199,0,0,jfoutz,,,"No, i think he's suggesting knowledge understanding and science as a whole depend on observable side effects. For example, i have a program that does in fact provide a counter example to fermat's last theorem. Unfortunately it does not print the result.<p>If you deny observable side effects as a requirement, you must accept that i do have a program that does that.<p>Most cs curriculums cover propositional logic. if you recall the truth table for implication, the false case always evaluates to true. my instructor used to call it the ""who cares"" case.<p>If you don't demand a witness for the proposition, the compiler is under no obligation to provide one.",1272694606
1310208,comment,1309536,1309919,0,0,aaronblohowiak,,,"You're optimistic!",1272694558
1310207,story,,,27,19,digamber_kamat,"Innovation for baby delivery. ",http://www.thingamababy.com/baby/2007/01/baby_patent_his.html,,1272694517
1310206,comment,1310105,1310199,0,0,tetha,,,"Compare to the reddit-thread and the other comments. I define boring as ""without side effects"", that is, without io-access, without access to volatile variables and such according to the C-Spec. Boring also is language dependant, of course, as different languages have different side effects.<p>And yes, as such, I define the theoretically interesting halting problem as practically boring, because I only care about the result my program computes and outputs. If there is no output, there is no output -- not even the possibility of output, no matter if my program runs in less than a second, an hour, a year or infinitely long.<p>Yes, technically they are differnt programs. Practically, I run the program, notice ""What the... how is it so fast?"", notice the missing printf in there, add it (while being happy about the change in semantics which saved me several minutes), see the result and do something useful.",1272694319
1310205,comment,1309973,1310177,0,0,aaronblohowiak,,,"and they may be delicious",1272694292
1310204,comment,1310105,1310198,0,0,barrkel,,,"Re C99 - the existence of an execution environment is certainly observable (it'll disappear with respect to the program when the program terminates), unless you try to argue that exit(0) has no observable side-effects according to the C standard, and thus we should expect code following exit(0) to also be executed, where I think we would be entering absurdity.<p>Re correctness: That the compiler optimizer cannot see past the halting problem is a general fact about compiler analysis, which you should be familiar with from most introductions to compiler theory. That an optimizer assumes without proof a solution to the halting problem for some sub-program would mean that it's an unreliable translator, because it is making unsound assumptions.<p>Of course, if your define your language such that it's OK to make unsound assumptions, that's another matter.",1272694254
1310203,comment,1309403,1309403,0,0,wooster,,,"Did anyone else here read this and immediately install VigLink on a site?",1272694217
1310202,comment,1309159,1310128,0,0,jjs,,,"The risk will only get worse the more he delays.<p>If attempting coitus would pose a health risk at 68, then he certainly shouldn't make an attempt at 69.",1272694171
1310201,comment,1309940,1310166,0,0,ben_h,,,"I should have copied and pasted instead of typing it out :) Thanks for the correction, fixed.",1272693970
1310199,comment,1310105,1310193,0,0,barrkel,,,"I don't think ""boring"" is the right technical term; are you suggesting that the halting problem itself is boring, since it explicitly only relates to whether programs terminate or not?<p>The compiler is not privileged enough to state what is boring and what isn't. The example program calculates something meaningful - if it terminated, it would mean that there was a solution found, contrary to Fermat's theorem.",1272693781
1310198,comment,1310105,1310184,0,0,neilc,,,"<i>Termination is an observable side-effect of a program</i><p>Not per the C99 spec, at least (5.1.2.3: ""Accessing a volatile object, modifying an object, modifying a file, or calling a function that does any of those operations are all side effects, which are changes in the state of the execution environment."")<p>Termination is ""observable"", but so is runtime, memory consumption, code size, and myriad other properties that a compiler is at liberty to manipulate.<p><i>Turing completeness is the black box beyond which a compiler's optimizer cannot see past, and it must, for correctness' sake, must give up when it cannot prove termination.</i><p>Correctness according to what standard?",1272693712
1310197,comment,1308582,1309720,0,0,makmanalp,,,"Awesome to see my city represented by others on HN. Just out of curiosity, what sort of gig do you guys do? Custom tailored solutions for clients etc?",1272693710
1310196,story,,,1,0,Uncle_Sam,"8bit killer is a first person shooter styled to resemble a NES game",http://www.locomalito.com/juegos_8bit_killer.php,,1272693642
